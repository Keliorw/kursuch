#include "stdafx.h"
#include <iostream>
#include <cstring>
#include <string>
#include <stdlib.h>
#include <fstream>
#include <iostream>
#include <windows.h>
using namespace std;

class User{
	protected:
		int UserID;
		string RaschShet;//Расчётный счёт
		string Name;
		string Password;
		double balance;//Баланс
		struct Order{//Для вывода и записи переводов
			string RSPlatel;//ID пользователя плательщика
			string RSPoluch;//ID пользователя получателя
			double money;//Сумма перевода
		};

		int action;//Переменная для хранения выбраного пользователем действия
	public:
		User(string RS){
			this->RaschShet = RS;//Устанвливаем расчётный счёт пользователя
			this->balance = 100;//Устанавливаем баланс пользователя
			this->action = 0;//Устанавливаем событие в значение 0
			long file_size;//Объявляем переменную для хранения места курсора
			bool Flag = true;//переменная для циклов while
			string RepeatPassword;//Переменная для записи повторного пароля
			ifstream fp("DataBase.txt");//открываем файл для чтения
			fp.seekg(0, ios::end);//Устанавливаем курсор в конец файла
			file_size = fp.tellg();//Берём место курсора в файле
			if(file_size == 0){//Если в файле нету ещё ни одной записи, то мы сразу регестрируем нового пользователя 
				fp.close(); // закрываем файл
				ofstream fp("DataBase.txt");//Подключаем файл базы данных
				cout << "Введите ваше имя: "; cin >> this->Name;//Спрашиваем имя у пользователя
				cout << "Создайте пароль: "; cin >> this->Password;//Спрашиваем пароль у пользователя
				while(Flag){
					cout << "Повторите пароль: "; cin >> RepeatPassword;//Просим повторить пароль
					if(this->Password == RepeatPassword){//Если совпадает, то сохраняем данные в базу
						Flag = false;//Устанавлеваем булевую переменную в значение false
					} else {
						cout << "Пароли не совпадают!\n";//Выводим ошибку
					}
				}
				const char *nameChar = this->Name.c_str();//Преобразуем строку с именем в строку const char *
				char NameResult[1024];//переменная для хранения преобразованной строки
				char PasswordResult[1024];//переменная для хранения преобразованной строки
				OemToAnsi(nameChar, NameResult);//Преобразуем строку в кодироаку поддерживающию русский язык
				nameChar = this->Password.c_str();//Преобразуем строку с паролем в строку const char *
				OemToAnsi(nameChar, PasswordResult);//Преобразуем строку в кодироаку поддерживающию русский язык
				fp << "ID: 1; Rasch_Schet: " << this->RaschShet << "; Name: " << NameResult 
					<< "; Password: " << PasswordResult << "; Balance: " << this->balance << "\n";//Записываем в файл информацию о пользователе
				this->UserID = 1;//Присваиваем ID пользователя
				cout << "Вы успешно создали новый расчётный счёт!\n\n";//Выводим сообщение о успешной регистрации
				fp.close();//Закрываем файл
			} else {
				fp.close(); // закрываем файл
				this->ShearchUserInDB();//Вызываем функцию для поиска пользователя по нашей базе данных
			}
		}
		//Ищет есть ли такой пользователь уже в базе данных
		int ShearchUserInDB(){
			ifstream fp("DataBase.txt");//Подключаем файл базы данных
			const int max_lenght = 1024;//Задаём константу для чтения все стркои из файла
			char line[max_lenght];//Создаём строку CHAR с длинной считываемой строки
			string WorkLine;//Рабочая строка
			string LastLine;//Последняя строка в файле
			char buff[1024];
			bool Flag = true;
			while(fp){//Пока файл не закончился мы его читаем
				fp.getline(line, max_lenght);//Берём строку длинной равной нашей константе
				WorkLine = string(line);//Конвертируем её в тип данных String
				if (!WorkLine.empty()){//Если строка не пустая идём дальше
					int pos = WorkLine.find(this->RaschShet);//Ищем в строке из файла позицию вхождения расчётного счёта 
					if (pos != -1){//Находим, то условие верно, иначе неверно
						if(this->RaschShet == WorkLine.substr(pos, 6)){//Берём из строки весь расчётный счёт и если он равен заданому пользователем, входим в аккаунт
							while(Flag){
								cout << "Введите ваше имя: "; cin >> this->Name;//Просим пользователя ввести имя
								string tmpLine = this->GetNameInDataBase(WorkLine);//Запрашиваем имя из базы данных
								const char *Name = tmpLine.c_str();//преобразуем строку в const char *
								AnsiToOem(Name, buff);//Меняем кодировку 
								tmpLine = buff;//Присваиваем обратно строке 
								if(this->Name == tmpLine){//Если Имена совпадают, то мы запрашиваем пароль
									Flag = false;//Устанавлеваем булевую переменную в значение false
								} else {
									cout << "Неверно введено имя!\n";//Выводим текст ошибки
								}
							}
							Flag = true;
							while(Flag){
								cout << "Введите пароль: "; cin >> this->Password;//Просим пользователя ввести пароль
								string tmpLine = this->GetPasswordInDataBase(WorkLine);//Запрашиваем пароль из базы данных
								const char *Password = tmpLine.c_str();//преобразуем строку в const char *
								AnsiToOem(Password, buff);//Меняем кодировку 
								tmpLine = buff;//Присваиваем обратно строке 
								if(this->Password == tmpLine){//Если пароли совпадают, то мы входим в аккаунт
									Flag = false;//Устанавлеваем булевую переменную в значение false
								} else {
									cout << "Неверно введён пароль!\n";//Выводим текст ошибки
								}
							}
							cout << "Вы вошли в аккаунт: " << WorkLine.substr(pos, 6) << endl;//выводим сообщение входа в аккаунт
							fp.close();//Закрываем файл
							string ID = this->GetIDinDataBase(WorkLine);//вызываем функцию и получаем ID из строки
							this->UserID = atoi(ID.c_str())+1;//Присваиваем ID пользователя
							return 0;//Отсанавливаем функцию, возвращая значение 0
						}
					}
					LastLine = WorkLine;//Присваиваем рабочую строку к переменной которая хранит последнюю строку и когда файл закончится тут будет последняя строка
				}
			}
			string lastID = this->GetIDinDataBase(LastLine);//вызываем функцию и получаем ID из строки
			fp.close();//Закрываем файл
			this->NewUser(lastID);//Вызываем функцию создания нового пользователя и передаём туда строку, котороая хранит в себе ID последнего пользователя
		}
		//Функция регестрирующая пользователя, в неё передаётся только полседний ID пользователя в БД
		void NewUser(string ID){
			bool Flag = true;//переменная для циклов while
			string RepeatPassword;//Переменная для записи повторного пароля
			ofstream fp("DataBase.txt", ios_base::app);//Открываем файл для записи в конце файла
			cout << "Введите ваше имя: "; cin >> this->Name;//Спрашиваем имя у пользователя
			cout << "Создайте пароль: "; cin >> this->Password;//Спрашиваем пароль у пользователя
			while(Flag){
				cout << "Повторите пароль: "; cin >> RepeatPassword;//Просим повторить пароль
				if(this->Password == RepeatPassword){//Если совпадает, то сохраняем данные в базу
					Flag = false;//Устанавлеваем булевую переменную в значение false
				} else {
					cout << "Пароли не совпадают!\n";//Выводим ошибку
				}
			}
			const char *nameChar = this->Name.c_str();//Преобразуем строку с именем в строку const char *
			char NameResult[1024];//переменная для хранения преобразованной строки
			char PasswordResult[1024];//переменная для хранения преобразованной строки
			OemToAnsi(nameChar, NameResult);//Преобразуем строку в кодироаку поддерживающию русский язык
			nameChar = this->Password.c_str();//Преобразуем строку с паролем в строку const char *
			OemToAnsi(nameChar, PasswordResult);//Преобразуем строку в кодироаку поддерживающию русский язык
			fp << "ID: " << atoi(ID.c_str())+1 << "; Rasch_Schet: " << this->RaschShet << "; Name: " << NameResult << "; Password: " << PasswordResult << "; Balance: " << this->balance << "\n";//Записываем в файл информацию о пользователе
			fp.close();//Закрываем файл
			this->UserID = atoi(ID.c_str())+1;//Присваиваем ID пользователя
			cout << "Вы успешно создали новый расчётный счёт!\n\n";//Выводим сообщение
		}
		//возвращает Имя из базы данных
		string GetNameInDataBase(string line){
			int Pos = line.find("Name: ");//Ищем вхождение подстроки в строке
			string WorkLine = line.substr(Pos);//Обрезаем строку до позиции вхождения подстроки выше
			Pos = WorkLine.find_first_of(";");//Находим первое вхождения символа ";"
			return WorkLine.substr(6, (Pos - 6));//Вырезаем из строки пароль и возвращаем его
		}
		//Возвращает пароль из базы данных
		string GetPasswordInDataBase(string line){
			int Pos = line.find("Password: ");//Ищем вхождение подстроки в строке
			string WorkLine = line.substr(Pos);//Обрезаем строку до позиции вхождения подстроки выше
			Pos = WorkLine.find_first_of(";");//Находим первое вхождения символа ";"
			return WorkLine.substr(10, (Pos - 10));//Вырезаем из строки пароль и возвращаем его
		}
		//Возвращает ID из строки 
		string GetIDinDataBase(string Line){
			int posID = Line.find("ID:");// ищем позицию ID: в строке
			int posEND = Line.find_first_of(";");//Ищем первое вхожение знака ";"
			return Line.substr(posID+4, (posEND - (posID+4)));//Получаем из строки значение ID
		}		
		//Сортирует структуру по расчётному счёту отправителя(по возрастанию)
		Order* SortTransaction(Order* ORDER, int n){
			int i;//Объявляем переменную для цикла for
			bool Flag = true;//Объявляем флаг и присваеваем ему значение true
			while(Flag){//Запускаем цикл, который будет работать пока в структуре ничего не перестанет меняться
				Flag = false;//Сразу устанавливаем в False
				for(i = 0; i < n-1; i++){
					if(ORDER[i].RSPlatel > ORDER[i+1].RSPlatel)//Если элемент массива под номером i больше чем элемент i+1, то выполняем выражение
					{
						Order temp = ORDER[i];//Сохраняем элемент i в перменной temp, для будущего присваения элементу i+1
						ORDER[i] = ORDER[i+1];//Присваиваем элементу под номером i значение элемента под номером i+1
						ORDER[i+1] = temp;//Присваиваем элемент i+1 в значение temp
						Flag = true;//Устанавливаем флаг в значение true
					}
				}
			}
			return ORDER;//Возвращаем отсортированный массив
		}
		//Сортирует структуру по расчётному счёту получателя(по возрастанию)
		Order* SortTransactionRSPol(Order* ORDER, int n){
			int i;//Объявляем переменную для цикла for
			bool Flag = true;//Объявляем флаг и присваеваем ему значение true
			while(Flag){//Запускаем цикл, который будет работать пока в структуре ничего не перестанет меняться
				Flag = false;//Сразу устанавливаем в False
				for(i = 0; i < n-1; i++){
					if(ORDER[i].RSPoluch > ORDER[i+1].RSPoluch)//Если элемент массива под номером i больше чем элемент i+1, то выполняем выражение
					{
						Order temp = ORDER[i];//Сохраняем элемент i в перменной temp, для будущего присваения элементу i+1
						ORDER[i] = ORDER[i+1];//Присваиваем элементу под номером i значение элемента под номером i+1
						ORDER[i+1] = temp;//Присваиваем элемент i+1 в значение temp
						Flag = true;//Устанавливаем флаг в значение true
					}
				}
			}
			return ORDER;//Возвращаем отсортированный массив
		}

		//Сортирует структуру по сумме транзакции(по возрастанию)
		Order* SortTransactionMoney(Order* ORDER, int n){
			int i;//Объявляем переменную для цикла for
			bool Flag = true;//Объявляем флаг и присваеваем ему значение true
			while(Flag){//Запускаем цикл, который будет работать пока в структуре ничего не перестанет меняться
				Flag = false;//Сразу устанавливаем в False
				for(i = 0; i < n-1; i++){
					if(ORDER[i].money > ORDER[i+1].money)//Если элемент массива под номером i больше чем элемент i+1, то выполняем выражение
					{
						Order temp = ORDER[i];//Сохраняем элемент i в перменной temp, для будущего присваения элементу i+1
						ORDER[i] = ORDER[i+1];//Присваиваем элементу под номером i значение элемента под номером i+1
						ORDER[i+1] = temp;//Присваиваем элемент i+1 в значение temp
						Flag = true;//Устанавливаем флаг в значение true
					}
				}
			}
			return ORDER;//Возвращаем отсортированный массив
		}

		//Запись транзакций в базу
		void WriteTransactionInDataBase(){
			bool Flag = true;//Объявляем флаг и присваеваем ему значение true
			int n, i;//Объявляем 2 целочисленные переменные для хранения кол-ва элементов структуры и для цикла for
			cout << "Введите кол-во транзакций, которые хотите добавить: "; cin >> n;//Запрашиваем кол-во транзакций которые надо будет добавить
			Order *ORDER = new Order[n];//Выделяем место в динамической памяти
			cout << "Расчётные счета надо вводить в полном формате. Пример: '408123'\n\n";//Просим пользователе вводить данные корректно
			for(i = 0; i < n; i++){
				while(Flag){//Пока данные не будут введены верно мы спрашиваем их повторно
					cout << " " << (i+1) << ") Введите расчётный счёт отправителя: ";  cin >> ORDER[i].RSPlatel;//Просим ввести расчётный счёт отправителя 
					Flag = this->CheckSchet(ORDER[i].RSPlatel);//Отправляем введённую информацию в функцию и проверяем, есть ли такая транзакция
					if(Flag){//Если расчётный счёт найден, то ничего не выводим, а иначе выводим ошибку
						cout << "Такого расчётного счёта нету\n";//Выводим текст ошибки
					}
				}
				Flag = true;//Устанавливаем FLAG в значение true
				while(Flag){//Пока данные не будут введены верно мы спрашиваем их повторно
					cout << " Введите расчётный счёт получателя: "; cin >> ORDER[i].RSPoluch;//Просим ввести расчётный счёт получателя
					if(ORDER[i].RSPlatel != ORDER[i].RSPoluch){//Если он такой же как и у отправителя, то выводим ошибку, иначе выполняем секцию true
						Flag = this->CheckSchet(ORDER[i].RSPoluch);
						if(Flag){//Если расчётный счёт найден, то ничего не выводим, а иначе выводим ошибку
							cout << "Такого расчётного счёта нету\n";//Выводим текст ошибки
						}
					} else {
						cout << "Расчётные счета не могут быть одинаковыми\n";//Выводим текст ошибки
					}
				}
				Flag = true;//Устанавливаем FLAG в значение true
				cout << "\n" << " Введите сумму перевода: "; cin >> ORDER[i].money;//Просим ввести сумму перевода
				cout << "\n\n";//Оформление
			}
			ORDER = this->SortTransaction(ORDER, n);//Сортируем транзакции перед выводом
			ofstream fp("Transaction.txt", ios_base::app);//Открываем файл для записи в конце файла
			cout << "Информация выведена в алфавитном порядке, при запросе выписки по счёту, можно выбрать способ сортировки ваших транзакций\n";
			cout << "--------------------------------------------\n\n";//Оформление
			for(i = 0; i < n; i++){
				/* Выводим информацию о записанных транзакциях */
				cout << "Расчётный счёт отправителя: " << ORDER[i].RSPlatel << "\n";
				cout << "Расчётный счёт получателя: " << ORDER[i].RSPoluch << "\n";
				cout << "Сумма перевода: " << ORDER[i].money << "\n\n";
				/* Выводим информацию о записанных транзакциях */
				/* Записываем информацию в файл */
				fp << "RS_PLATELSHIKA: " << ORDER[i].RSPlatel << "; RS_POLUCAHTELYA: " << ORDER[i].RSPoluch << "; SUM_TRUNSACTION: " << ORDER[i].money << ";\n";
				/* Записываем информацию в файл */
			}
			cout << "--------------------------------------------\n";//Оформление
			cout << "Новых транзакций: " << n << "\nУспешно записано!!!\n\n";
			fp.close();//Закрываем файл
		}

		//Проверка существует ли такой счёт
		bool CheckSchet(string Schet){
			ifstream fp("DataBase.txt");//Подключаем файл базы данных
			const int max_lenght = 1024;//Задаём константу для чтения все стркои из файла
			char line[max_lenght];//Создаём строку CHAR с длинной считываемой строки
			string WorkLine;//Рабочая строка
			while(fp){//Пока файл не закончился мы его читаем
				fp.getline(line, max_lenght);//Берём строку длинной равной нашей константе
				WorkLine = string(line);//Конвертируем её в тип данных String
				if (!WorkLine.empty()){//Если строка не пустая идём дальше
					int pos = WorkLine.find(Schet);//Ищем в строке из файла позицию вхождения расчётного счёта 
					if (pos != -1){//Находим, то условие верно, иначе неверно
						if(Schet == WorkLine.substr(pos, 6)){//Берём из строки весь расчётный счёт и если он равен заданому пользователем, входим в аккаунт
							fp.close();//Закрываем файл
							return false;
						}
					}
				}
			}
			return true;
		}
		//Выводит все транзакции этого аккаунта в алфавитном порядке
		int WriteHistoryTransaction(){
			const int max_lenght = 1024;//Задаём константу для чтения все стркои из файла
			char line[max_lenght];//Создаём строку CHAR с длинной считываемой строки
			long file_size;//Объявляем переменную для хранения места курсора
			int n = 0, i = 0, TypeSort = 0;
			bool Flag = true;
			Order *ORDER;
			string WorkLine;//Рабочая строка
			ifstream fp("Transaction.txt");//Открываем файл для чтения
			fp.seekg(0, ios::end);//Устанавливаем курсор в конец файла
			file_size = fp.tellg();//Берём место курсора в файле
			if(file_size == 0){//Если в файле нету ещё ни одной записи, то мы выводим сообщение об этом
				cout << "У нас нет ещё ни одной транзакции\n\n";//Вывод ошибки
				fp.close();//Закрываем файл
				return 0;
			} else {
				/* Подсчитываем кол-во транзакций, что бы потмо выделить память */
				fp.seekg( 0 );
				while(fp){//Пока файл не закончился мы его читаем
					fp.getline(line, max_lenght);//Берём строку длинной равной нашей константе
					WorkLine = string(line);//Конвертируем её в тип данных String
					if (!WorkLine.empty()){//Если строка не пустая идём дальше
						int pos = WorkLine.find(this->RaschShet);//Ищем в строке из файла позицию вхождения расчётного счёта 
						if (pos != -1){//Находим, то условие верно, иначе неверно
							n++;
						}
					}
				}
				fp.close();
				/* Подсчитываем кол-во транзакций, что бы потом выделить память */
				ifstream fp("Transaction.txt");//Открываем файл для чтения
				ORDER = new Order[n];
				fp.seekg( 0 );
				while(fp){//Пока файл не закончился мы его читаем
					fp.getline(line, max_lenght);//Берём строку длинной равной нашей константе
					WorkLine = string(line);//Конвертируем её в тип данных String
					if (!WorkLine.empty()){//Если строка не пустая идём дальше
						int pos = WorkLine.find(this->RaschShet);//Ищем в строке из файла позицию вхождения расчётного счёта 
						if (pos != -1){//Находим, то условие верно, иначе неверно
							/* Находим вхождение всех нужных нам переменных */
							int posInfo1 = WorkLine.find("RS_PLATELSHIKA:");
							int posInfo2 = WorkLine.find("RS_POLUCAHTELYA:");
							int posInfo3 = WorkLine.find("SUM_TRUNSACTION:");
							/* Находим вхождение всех нужных нам переменных */
							/* Присваиваем эти переменные элементам нашей структуры */
							ORDER[i].RSPlatel = WorkLine.substr(posInfo1+16, (WorkLine.find_first_of(";") - (posInfo1+16)));
							ORDER[i].RSPoluch = WorkLine.substr(posInfo2+17, 6);
							string money = WorkLine.substr(posInfo3+17, (WorkLine.find_last_of(";") - (posInfo1+17)));
							ORDER[i].money = atoi(money.c_str());
							i++;
							/* Присваиваем эти переменные элементам нашей структуры */
						}
					}
				}	
			}
			while(TypeSort <= 0 || TypeSort >= 4){
				cout << "Выберите сортировку транзакций вашего расчётного счёта:\n\n";
				cout << "1) По расчётному счёту плательщика(по возрастанию)\n";
				cout << "2) По расчётному счёту получателя(по возрастанию)\n";
				cout << "3) По сумму транзакции(по возрастанию)\n";
				cout << "Введите номер пункта нужной вам сортировки: "; cin >> TypeSort;
				cout << "\n\n";
			}
			switch (TypeSort){
				case 1:
					ORDER = this->SortTransaction(ORDER, n);//Сортируем транзакции по расчётному счёту плательщика
					break;
				case 2:
					ORDER = this->SortTransactionRSPol(ORDER, n);//Сортируем транзакции по расчётному счёту получателя
					break;
				case 3:
					ORDER = this->SortTransactionMoney(ORDER, n);//Соритруем транзакции по сумме транзакции
				default:
					break;
			}
			cout << "--------------------------------------------\n\n";//Оформление
			for(i = 0; i < n; i++){
				/* Выводим информацию о записанных транзакциях */
				cout << "Расчётный счёт отправителя: " << ORDER[i].RSPlatel << "\n";
				cout << "Расчётный счёт получателя: " << ORDER[i].RSPoluch << "\n";
				cout << "Сумма перевода: " << ORDER[i].money << "\n\n";
				/* Выводим информацию о записанных транзакциях */
			}
			cout << "--------------------------------------------\n\n";//Оформление
			fp.close();//Закрываем файл
		}

		/* Всё для взоимодействия с пользователем и проверки его действий */
		//отрисовывает баланс пользователя
		void WriteBalance(){
			cout << "Ваш баланс: " << this->balance << "\n\n";
		}

		//отрисовывает расчётный счёт пользователя
		void WriteSchet(){
			cout << "Ваш расчётный счёт: " << this->RaschShet << "\n\n";
		}

		//Даёт выбор действий пользователю
		void TheChoice(){
			this->action = 0;
			while(this->action <= 0 || this->action > 5){
				cout << "Выберите действие, которое хотите совершить:\n\n";
				cout << "1) Записать историю сделок\n";
				cout << "2) Показать выписку вашего расчётного счёта\n";
				cout << "3) Показать номер вашего расчётного счёта\n";
				cout << "4) Показать баланс вашего расчётного счёта\n";
				cout << "5) Завершить и выйти\n\n";
				cout << "Введите номер пункта нужного вам действия: "; cin >> this->action;
				cout << "\n\n";
			}
		}

		//Возвращает значение выбранного действия хранящееся в переменной action
		int GetAction(){
			return this->action;
		}
		/* Всё для взоимодействия с пользователем и проверки его действий */
};
int main()
{
	setlocale(LC_ALL,"Russian");//Делаем текст на человеко понятном языке)))
	bool Flag = true;//Флажок для While
	string RS;//Строка для записи расчётного счёта в базу

	while(Flag){//Пока не будет введено правлиьное сообщение, цикл будет повторяться
		cout << "Для пользования нашими услугами создайте себе расчётный счёт или введите существующий в формате '123' без приставки 408" << endl; cin >> RS;//Просим ввести номер расчётного счёта
		if (RS.size() == 3){//Если строка меньше или больше 3-х символов, повторяем цикл
			if(RS.find_first_not_of("0123456789") == string::npos){//Если в стркое есть что-то помимо этих символов "0123456789" повторяем цикл
				Flag = false;//Устанавливаем флаг в значение неверно и цикл заканчивается
			}
		}
	}
	RS = "408"+RS;//Подставляем номер обозначеющий что это счёт физического лица
	User User(RS);//Создаём класс и отправляем туда номер расчётного счёта
	User.TheChoice();//Спрашиваем у пользователя, что он хочет сделать в аккаунте
	while(User.GetAction() != 5)//Пока пользователь не выбрал 5-е действие, он будет работать с аккаунтом
		switch (User.GetAction()){//проверяем что выбрал прользователь
			case 1:
				User.WriteTransactionInDataBase();//Вызываем функцию, для записи новых транзакций в базу
				User.TheChoice();//Спрашиваем у пользователя, что он хочет сделать в аккаунте
				break;
			case 2:
				User.WriteHistoryTransaction();//Вызываем функцию, которая выводит все транзакции этого аккаунта в алфавитном порядке
				User.TheChoice();//Спрашиваем у пользователя, что он хочет сделать в аккаунте
				break;
			case 3:
				cout << "--------------------------------------------\n\n";//Оформление
				User.WriteSchet();//Выводит номер счёта
				cout << "--------------------------------------------\n\n";//Оформление
				User.TheChoice();//Спрашиваем у пользователя, что он хочет сделать в аккаунте
				break;
			case 4:
				cout << "--------------------------------------------\n\n";//Оформление
				User.WriteBalance();//Выводит баланс аккаунта
				cout << "--------------------------------------------\n\n";//Оформление
				User.TheChoice();//Спрашиваем у пользователя, что он хочет сделать в аккаунте
				break;
			default: 
				cout << "Ошибка данное действие не найдено :'(" << endl;
				break;
		};
	system ("pause");
	return 0;
}